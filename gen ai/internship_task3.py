# -*- coding: utf-8 -*-
"""internship-task3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J245J7XjsdGknin4CfCqQaW34dd5BbdH
"""

# Import necessary libraries
from collections import defaultdict, Counter
import random

# Define the text for training
text = "this is a simple example of a Markov chain text generation example"

# Function to build the character-based Markov chain model
def build_char_markov_chain(text):
    markov_chain = defaultdict(Counter)
    for i in range(len(text) - 1):
        current_char = text[i]
        next_char = text[i + 1]
        markov_chain[current_char][next_char] += 1
    return markov_chain

# Function to generate text using the character-based Markov chain model
def generate_text_char(markov_chain, start_char, length=100):
    current_char = start_char
    result = start_char
    for _ in range(length - 1):
        next_chars = list(markov_chain[current_char].keys())
        if not next_chars:
            break
        next_char = random.choices(next_chars, weights=markov_chain[current_char].values())[0]
        result += next_char
        current_char = next_char
    return result

# Build the Markov chain model
char_markov_chain = build_char_markov_chain(text)

# Generate text
generated_text_char = generate_text_char(char_markov_chain, start_char="t", length=50)
print("Character-Based Generated Text:")
print(generated_text_char)

import random
from collections import defaultdict

class MarkovChain:
    def __init__(self, n=2):
        self.n = n  # Number of words to consider for state transitions
        self.model = defaultdict(list)

    def train(self, text):
        # Split text into words
        words = text.split()
        for i in range(len(words) - self.n):
            # Create a tuple as the state from n consecutive words
            state = tuple(words[i:i + self.n])
            next_word = words[i + self.n]
            self.model[state].append(next_word)

    def generate(self, length=50):
        # Randomly choose a starting state
        state = random.choice(list(self.model.keys()))
        result = list(state)

        # Generate the next words
        for _ in range(length - self.n):
            next_word = random.choice(self.model[state])
            result.append(next_word)
            state = tuple(result[-self.n:])  # Update the state

        return ' '.join(result)

# Load and read the dataset from your file path
file_path = "/content/dialogs.txt"  # Your dataset path
with open(file_path, 'r', encoding='utf-8') as file:
    data = file.read()

# Create an instance of the MarkovChain class
markov_chain = MarkovChain(n=3)  # You can adjust 'n' for longer states
markov_chain.train(data)

# Generate text
generated_text = markov_chain.generate(length=40)  # You can adjust the length of generated text
print(generated_text)



